<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>src.modeling.simulation_based_calibration_helpers API documentation</title>
<meta name="description" content="Helpers for organizing simualtaion-based calibrations." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.modeling.simulation_based_calibration_helpers</code></h1>
</header>
<section id="section-intro">
<p>Helpers for organizing simualtaion-based calibrations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Helpers for organizing simualtaion-based calibrations.&#34;&#34;&#34;

import random
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional

import arviz as az
import numpy as np
import pandas as pd

from src.data_processing import achilles as achelp
from src.string_functions import prefixed_count


class MockDataSizes(str, Enum):
    &#34;&#34;&#34;Options for dataset seizes when generating mock data.&#34;&#34;&#34;

    small = &#34;small&#34;
    medium = &#34;medium&#34;
    large = &#34;large&#34;


class SBCResults:
    &#34;&#34;&#34;Results from a single round of SBC.&#34;&#34;&#34;

    priors: Dict[str, Any]
    inference_obj: az.InferenceData
    posterior_summary: pd.DataFrame

    def __init__(
        self,
        priors: Dict[str, Any],
        inference_obj: az.InferenceData,
        posterior_summary: pd.DataFrame,
    ):
        &#34;&#34;&#34;Create an instance of SBCResults.

        Args:
            priors (Dict[str, Any]): Priors representing the &#39;true&#39; values.
            inference_obj (az.InferenceData): Fitting results.
            posterior_summary (pd.DataFrame): A summary of the posteriors.
        &#34;&#34;&#34;
        self.priors = priors
        self.inference_obj = inference_obj
        self.posterior_summary = posterior_summary


class SBCFileManager:
    &#34;&#34;&#34;Manages the results from a round of simulation-based calibration.&#34;&#34;&#34;

    dir: Path
    inference_data_path: Path
    priors_path_set: Path
    priors_path_get: Path
    posterior_summary_path: Path

    sbc_results: Optional[SBCResults] = None

    def __init__(self, dir: Path):
        &#34;&#34;&#34;Create a SBCFileManager.

        Args:
            dir (Path): The directory where the data is stored.
        &#34;&#34;&#34;
        self.dir = dir
        self.inference_data_path = dir / &#34;inference-data.netcdf&#34;
        self.priors_path_set = dir / &#34;priors&#34;
        self.priors_path_get = dir / &#34;priors.npz&#34;
        self.posterior_summary_path = dir / &#34;posterior-summary.csv&#34;

    def save_sbc_results(
        self,
        priors: Dict[str, Any],
        inference_obj: az.InferenceData,
        posterior_summary: pd.DataFrame,
    ) -&gt; None:
        &#34;&#34;&#34;Save the results from a round of SBC.

        Args:
            priors (Dict[str, Any]): Priors representing the &#39;true&#39; values.
            inference_obj (az.InferenceData): Fitting results.
            posterior_summary (pd.DataFrame): A summary of the posteriors.
        &#34;&#34;&#34;
        inference_obj.to_netcdf(self.inference_data_path.as_posix())
        np.savez(self.priors_path_set.as_posix(), **priors)
        posterior_summary.to_csv(
            self.posterior_summary_path.as_posix(), index_label=&#34;parameter&#34;
        )

    def _tidy_numpy_files(self, files: Any) -&gt; Dict[str, np.ndarray]:
        d: Dict[str, np.ndarray] = {}
        for k in files.files:
            d[k] = files[k]
        return d

    def get_sbc_results(self, re_read: bool = False) -&gt; SBCResults:
        &#34;&#34;&#34;Retrieve results of a round of SBC.

        Args:
            re_read (bool, optional): Should the results be re-read from file?
              Defaults to False.

        Returns:
            SBCResults: The results from the round of SBC.
        &#34;&#34;&#34;
        if self.sbc_results is not None and not re_read:
            return self.sbc_results

        inference_obj = az.from_netcdf(self.inference_data_path)
        priors_files = np.load(self.priors_path_get.as_posix())
        priors = self._tidy_numpy_files(priors_files)
        posterior_summary = pd.read_csv(
            self.posterior_summary_path, index_col=&#34;parameter&#34;
        )

        self.sbc_results = SBCResults(
            priors=priors,
            inference_obj=inference_obj,
            posterior_summary=posterior_summary,
        )
        return self.sbc_results

    def all_data_exists(self) -&gt; bool:
        &#34;&#34;&#34;Confirm that all data exists.

        Returns:
            bool: True if all of the data exists, else false.
        &#34;&#34;&#34;
        for p in [
            self.priors_path_get,
            self.posterior_summary_path,
            self.inference_data_path,
        ]:
            if not p.exists():
                return False
        return True


def generate_mock_achilles_data(
    n_genes: int,
    n_sgrnas_per_gene: int,
    n_cell_lines: int,
    n_batches: int,
    n_kras_types: Optional[int] = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate mock Achilles data.

    Each sgRNA maps to a single gene. Each cell lines only received on pDNA batch.
    Each cell line / sgRNA combination occurs exactly once.

    Args:
        n_genes (int): Number of genes.
        n_sgrnas_per_gene (int): Number of sgRNAs per gene.
        n_cell_lines (int): Number of cell lines.
        n_batches (int): Number of pDNA batchs.
        n_kras_types (Optional[int], optional): Number of types of KRAS mutations to
          include. Defaults to None which ignores this attribute altogether.

    Returns:
        pd.DataFrame: A pandas data frame the resembles the Achilles data.
    &#34;&#34;&#34;
    cell_lines = prefixed_count(&#34;cellline&#34;, n=n_cell_lines)
    batches = prefixed_count(&#34;batch&#34;, n=n_batches)
    batch_map = pd.DataFrame(
        {
            &#34;depmap_id&#34;: cell_lines,
            &#34;p_dna_batch&#34;: np.random.choice(batches, n_cell_lines),
        }
    )

    genes = prefixed_count(&#34;gene&#34;, n=n_genes)
    sgrnas = [prefixed_count(gene + &#34;_sgrna&#34;, n=n_sgrnas_per_gene) for gene in genes]
    sgnra_map = pd.DataFrame(
        {
            &#34;hugo_symbol&#34;: np.repeat(genes, n_sgrnas_per_gene),
            &#34;sgrna&#34;: np.array(sgrnas).flatten(),
        }
    )

    df = (
        pd.DataFrame(
            {
                &#34;depmap_id&#34;: np.repeat(cell_lines, n_genes),
                &#34;hugo_symbol&#34;: np.tile(genes, n_cell_lines),
            }
        )
        .merge(batch_map, on=&#34;depmap_id&#34;)
        .merge(sgnra_map, on=&#34;hugo_symbol&#34;)
        .reset_index(drop=True)
    )

    kras_types: List[str] = [&#34;WT&#34;, &#34;G12D&#34;, &#34;G13D&#34;, &#34;A146T&#34;, &#34;Q61L&#34;, &#34;G12C&#34;, &#34;G12R&#34;]
    if n_kras_types is not None:
        if n_kras_types &gt; len(kras_types):
            raise ValueError(
                f&#34;Please use less than {len(kras_types)} types of KRAS mutations.&#34;
            )
        elif n_kras_types &lt;= 0:
            raise ValueError(&#34;Number of KRAS types must be positive and non-zero.&#34;)

        kras_types = kras_types[:n_kras_types]
        kras_assignments = pd.DataFrame(
            {
                &#34;depmap_id&#34;: cell_lines,
                &#34;kras_mutation&#34;: random.choices(kras_types, k=len(cell_lines)),
            }
        )
        df = df.merge(kras_assignments, how=&#34;left&#34;, on=&#34;depmap_id&#34;)

    df = achelp.set_achilles_categorical_columns(df, cols=df.columns.tolist())

    # Mock values for gene copy number.
    df[&#34;copy_number&#34;] = 2 ** np.random.normal(1, 0.5, df.shape[0])
    # df[&#34;log2_cn&#34;] = np.log2(df.gene_cn + 1)
    # df = achelp.zscale_cna_by_group(
    #     df,
    #     gene_cn_col=&#34;log2_cn&#34;,
    #     new_col=&#34;z_log2_cn&#34;,
    #     groupby_cols=[&#34;depmap_id&#34;],
    #     cn_max=np.log2(10),
    # )

    df[&#34;lfc&#34;] = np.random.normal(0, 2, df.shape[0])
    return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.modeling.simulation_based_calibration_helpers.generate_mock_achilles_data"><code class="name flex">
<span>def <span class="ident">generate_mock_achilles_data</span></span>(<span>n_genes: int, n_sgrnas_per_gene: int, n_cell_lines: int, n_batches: int, n_kras_types: Optional[int] = None) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Generate mock Achilles data.</p>
<p>Each sgRNA maps to a single gene. Each cell lines only received on pDNA batch.
Each cell line / sgRNA combination occurs exactly once.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_genes</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of genes.</dd>
<dt><strong><code>n_sgrnas_per_gene</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of sgRNAs per gene.</dd>
<dt><strong><code>n_cell_lines</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of cell lines.</dd>
<dt><strong><code>n_batches</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pDNA batchs.</dd>
<dt><strong><code>n_kras_types</code></strong> :&ensp;<code>Optional[int]</code>, optional</dt>
<dd>Number of types of KRAS mutations to
include. Defaults to None which ignores this attribute altogether.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A pandas data frame the resembles the Achilles data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_mock_achilles_data(
    n_genes: int,
    n_sgrnas_per_gene: int,
    n_cell_lines: int,
    n_batches: int,
    n_kras_types: Optional[int] = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate mock Achilles data.

    Each sgRNA maps to a single gene. Each cell lines only received on pDNA batch.
    Each cell line / sgRNA combination occurs exactly once.

    Args:
        n_genes (int): Number of genes.
        n_sgrnas_per_gene (int): Number of sgRNAs per gene.
        n_cell_lines (int): Number of cell lines.
        n_batches (int): Number of pDNA batchs.
        n_kras_types (Optional[int], optional): Number of types of KRAS mutations to
          include. Defaults to None which ignores this attribute altogether.

    Returns:
        pd.DataFrame: A pandas data frame the resembles the Achilles data.
    &#34;&#34;&#34;
    cell_lines = prefixed_count(&#34;cellline&#34;, n=n_cell_lines)
    batches = prefixed_count(&#34;batch&#34;, n=n_batches)
    batch_map = pd.DataFrame(
        {
            &#34;depmap_id&#34;: cell_lines,
            &#34;p_dna_batch&#34;: np.random.choice(batches, n_cell_lines),
        }
    )

    genes = prefixed_count(&#34;gene&#34;, n=n_genes)
    sgrnas = [prefixed_count(gene + &#34;_sgrna&#34;, n=n_sgrnas_per_gene) for gene in genes]
    sgnra_map = pd.DataFrame(
        {
            &#34;hugo_symbol&#34;: np.repeat(genes, n_sgrnas_per_gene),
            &#34;sgrna&#34;: np.array(sgrnas).flatten(),
        }
    )

    df = (
        pd.DataFrame(
            {
                &#34;depmap_id&#34;: np.repeat(cell_lines, n_genes),
                &#34;hugo_symbol&#34;: np.tile(genes, n_cell_lines),
            }
        )
        .merge(batch_map, on=&#34;depmap_id&#34;)
        .merge(sgnra_map, on=&#34;hugo_symbol&#34;)
        .reset_index(drop=True)
    )

    kras_types: List[str] = [&#34;WT&#34;, &#34;G12D&#34;, &#34;G13D&#34;, &#34;A146T&#34;, &#34;Q61L&#34;, &#34;G12C&#34;, &#34;G12R&#34;]
    if n_kras_types is not None:
        if n_kras_types &gt; len(kras_types):
            raise ValueError(
                f&#34;Please use less than {len(kras_types)} types of KRAS mutations.&#34;
            )
        elif n_kras_types &lt;= 0:
            raise ValueError(&#34;Number of KRAS types must be positive and non-zero.&#34;)

        kras_types = kras_types[:n_kras_types]
        kras_assignments = pd.DataFrame(
            {
                &#34;depmap_id&#34;: cell_lines,
                &#34;kras_mutation&#34;: random.choices(kras_types, k=len(cell_lines)),
            }
        )
        df = df.merge(kras_assignments, how=&#34;left&#34;, on=&#34;depmap_id&#34;)

    df = achelp.set_achilles_categorical_columns(df, cols=df.columns.tolist())

    # Mock values for gene copy number.
    df[&#34;copy_number&#34;] = 2 ** np.random.normal(1, 0.5, df.shape[0])
    # df[&#34;log2_cn&#34;] = np.log2(df.gene_cn + 1)
    # df = achelp.zscale_cna_by_group(
    #     df,
    #     gene_cn_col=&#34;log2_cn&#34;,
    #     new_col=&#34;z_log2_cn&#34;,
    #     groupby_cols=[&#34;depmap_id&#34;],
    #     cn_max=np.log2(10),
    # )

    df[&#34;lfc&#34;] = np.random.normal(0, 2, df.shape[0])
    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.modeling.simulation_based_calibration_helpers.MockDataSizes"><code class="flex name class">
<span>class <span class="ident">MockDataSizes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for dataset seizes when generating mock data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockDataSizes(str, Enum):
    &#34;&#34;&#34;Options for dataset seizes when generating mock data.&#34;&#34;&#34;

    small = &#34;small&#34;
    medium = &#34;medium&#34;
    large = &#34;large&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="src.modeling.simulation_based_calibration_helpers.MockDataSizes.large"><code class="name">var <span class="ident">large</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.modeling.simulation_based_calibration_helpers.MockDataSizes.medium"><code class="name">var <span class="ident">medium</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.modeling.simulation_based_calibration_helpers.MockDataSizes.small"><code class="name">var <span class="ident">small</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="src.modeling.simulation_based_calibration_helpers.SBCFileManager"><code class="flex name class">
<span>class <span class="ident">SBCFileManager</span></span>
<span>(</span><span>dir: pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages the results from a round of simulation-based calibration.</p>
<p>Create a SBCFileManager.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The directory where the data is stored.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SBCFileManager:
    &#34;&#34;&#34;Manages the results from a round of simulation-based calibration.&#34;&#34;&#34;

    dir: Path
    inference_data_path: Path
    priors_path_set: Path
    priors_path_get: Path
    posterior_summary_path: Path

    sbc_results: Optional[SBCResults] = None

    def __init__(self, dir: Path):
        &#34;&#34;&#34;Create a SBCFileManager.

        Args:
            dir (Path): The directory where the data is stored.
        &#34;&#34;&#34;
        self.dir = dir
        self.inference_data_path = dir / &#34;inference-data.netcdf&#34;
        self.priors_path_set = dir / &#34;priors&#34;
        self.priors_path_get = dir / &#34;priors.npz&#34;
        self.posterior_summary_path = dir / &#34;posterior-summary.csv&#34;

    def save_sbc_results(
        self,
        priors: Dict[str, Any],
        inference_obj: az.InferenceData,
        posterior_summary: pd.DataFrame,
    ) -&gt; None:
        &#34;&#34;&#34;Save the results from a round of SBC.

        Args:
            priors (Dict[str, Any]): Priors representing the &#39;true&#39; values.
            inference_obj (az.InferenceData): Fitting results.
            posterior_summary (pd.DataFrame): A summary of the posteriors.
        &#34;&#34;&#34;
        inference_obj.to_netcdf(self.inference_data_path.as_posix())
        np.savez(self.priors_path_set.as_posix(), **priors)
        posterior_summary.to_csv(
            self.posterior_summary_path.as_posix(), index_label=&#34;parameter&#34;
        )

    def _tidy_numpy_files(self, files: Any) -&gt; Dict[str, np.ndarray]:
        d: Dict[str, np.ndarray] = {}
        for k in files.files:
            d[k] = files[k]
        return d

    def get_sbc_results(self, re_read: bool = False) -&gt; SBCResults:
        &#34;&#34;&#34;Retrieve results of a round of SBC.

        Args:
            re_read (bool, optional): Should the results be re-read from file?
              Defaults to False.

        Returns:
            SBCResults: The results from the round of SBC.
        &#34;&#34;&#34;
        if self.sbc_results is not None and not re_read:
            return self.sbc_results

        inference_obj = az.from_netcdf(self.inference_data_path)
        priors_files = np.load(self.priors_path_get.as_posix())
        priors = self._tidy_numpy_files(priors_files)
        posterior_summary = pd.read_csv(
            self.posterior_summary_path, index_col=&#34;parameter&#34;
        )

        self.sbc_results = SBCResults(
            priors=priors,
            inference_obj=inference_obj,
            posterior_summary=posterior_summary,
        )
        return self.sbc_results

    def all_data_exists(self) -&gt; bool:
        &#34;&#34;&#34;Confirm that all data exists.

        Returns:
            bool: True if all of the data exists, else false.
        &#34;&#34;&#34;
        for p in [
            self.priors_path_get,
            self.posterior_summary_path,
            self.inference_data_path,
        ]:
            if not p.exists():
                return False
        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.modeling.simulation_based_calibration_helpers.SBCFileManager.sbc_results"><code class="name">var <span class="ident">sbc_results</span> : Optional[<a title="src.modeling.simulation_based_calibration_helpers.SBCResults" href="#src.modeling.simulation_based_calibration_helpers.SBCResults">SBCResults</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.modeling.simulation_based_calibration_helpers.SBCFileManager.all_data_exists"><code class="name flex">
<span>def <span class="ident">all_data_exists</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Confirm that all data exists.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if all of the data exists, else false.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_data_exists(self) -&gt; bool:
    &#34;&#34;&#34;Confirm that all data exists.

    Returns:
        bool: True if all of the data exists, else false.
    &#34;&#34;&#34;
    for p in [
        self.priors_path_get,
        self.posterior_summary_path,
        self.inference_data_path,
    ]:
        if not p.exists():
            return False
    return True</code></pre>
</details>
</dd>
<dt id="src.modeling.simulation_based_calibration_helpers.SBCFileManager.get_sbc_results"><code class="name flex">
<span>def <span class="ident">get_sbc_results</span></span>(<span>self, re_read: bool = False) -> <a title="src.modeling.simulation_based_calibration_helpers.SBCResults" href="#src.modeling.simulation_based_calibration_helpers.SBCResults">SBCResults</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve results of a round of SBC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>re_read</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the results be re-read from file?
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.modeling.simulation_based_calibration_helpers.SBCResults" href="#src.modeling.simulation_based_calibration_helpers.SBCResults">SBCResults</a></code></dt>
<dd>The results from the round of SBC.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sbc_results(self, re_read: bool = False) -&gt; SBCResults:
    &#34;&#34;&#34;Retrieve results of a round of SBC.

    Args:
        re_read (bool, optional): Should the results be re-read from file?
          Defaults to False.

    Returns:
        SBCResults: The results from the round of SBC.
    &#34;&#34;&#34;
    if self.sbc_results is not None and not re_read:
        return self.sbc_results

    inference_obj = az.from_netcdf(self.inference_data_path)
    priors_files = np.load(self.priors_path_get.as_posix())
    priors = self._tidy_numpy_files(priors_files)
    posterior_summary = pd.read_csv(
        self.posterior_summary_path, index_col=&#34;parameter&#34;
    )

    self.sbc_results = SBCResults(
        priors=priors,
        inference_obj=inference_obj,
        posterior_summary=posterior_summary,
    )
    return self.sbc_results</code></pre>
</details>
</dd>
<dt id="src.modeling.simulation_based_calibration_helpers.SBCFileManager.save_sbc_results"><code class="name flex">
<span>def <span class="ident">save_sbc_results</span></span>(<span>self, priors: Dict[str, Any], inference_obj: arviz.data.inference_data.InferenceData, posterior_summary: pandas.core.frame.DataFrame) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Save the results from a round of SBC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>priors</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Priors representing the 'true' values.</dd>
<dt><strong><code>inference_obj</code></strong> :&ensp;<code>az.InferenceData</code></dt>
<dd>Fitting results.</dd>
<dt><strong><code>posterior_summary</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A summary of the posteriors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_sbc_results(
    self,
    priors: Dict[str, Any],
    inference_obj: az.InferenceData,
    posterior_summary: pd.DataFrame,
) -&gt; None:
    &#34;&#34;&#34;Save the results from a round of SBC.

    Args:
        priors (Dict[str, Any]): Priors representing the &#39;true&#39; values.
        inference_obj (az.InferenceData): Fitting results.
        posterior_summary (pd.DataFrame): A summary of the posteriors.
    &#34;&#34;&#34;
    inference_obj.to_netcdf(self.inference_data_path.as_posix())
    np.savez(self.priors_path_set.as_posix(), **priors)
    posterior_summary.to_csv(
        self.posterior_summary_path.as_posix(), index_label=&#34;parameter&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.modeling.simulation_based_calibration_helpers.SBCResults"><code class="flex name class">
<span>class <span class="ident">SBCResults</span></span>
<span>(</span><span>priors: Dict[str, Any], inference_obj: arviz.data.inference_data.InferenceData, posterior_summary: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Results from a single round of SBC.</p>
<p>Create an instance of SBCResults.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>priors</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Priors representing the 'true' values.</dd>
<dt><strong><code>inference_obj</code></strong> :&ensp;<code>az.InferenceData</code></dt>
<dd>Fitting results.</dd>
<dt><strong><code>posterior_summary</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A summary of the posteriors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SBCResults:
    &#34;&#34;&#34;Results from a single round of SBC.&#34;&#34;&#34;

    priors: Dict[str, Any]
    inference_obj: az.InferenceData
    posterior_summary: pd.DataFrame

    def __init__(
        self,
        priors: Dict[str, Any],
        inference_obj: az.InferenceData,
        posterior_summary: pd.DataFrame,
    ):
        &#34;&#34;&#34;Create an instance of SBCResults.

        Args:
            priors (Dict[str, Any]): Priors representing the &#39;true&#39; values.
            inference_obj (az.InferenceData): Fitting results.
            posterior_summary (pd.DataFrame): A summary of the posteriors.
        &#34;&#34;&#34;
        self.priors = priors
        self.inference_obj = inference_obj
        self.posterior_summary = posterior_summary</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.modeling" href="index.html">src.modeling</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.modeling.simulation_based_calibration_helpers.generate_mock_achilles_data" href="#src.modeling.simulation_based_calibration_helpers.generate_mock_achilles_data">generate_mock_achilles_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.modeling.simulation_based_calibration_helpers.MockDataSizes" href="#src.modeling.simulation_based_calibration_helpers.MockDataSizes">MockDataSizes</a></code></h4>
<ul class="">
<li><code><a title="src.modeling.simulation_based_calibration_helpers.MockDataSizes.large" href="#src.modeling.simulation_based_calibration_helpers.MockDataSizes.large">large</a></code></li>
<li><code><a title="src.modeling.simulation_based_calibration_helpers.MockDataSizes.medium" href="#src.modeling.simulation_based_calibration_helpers.MockDataSizes.medium">medium</a></code></li>
<li><code><a title="src.modeling.simulation_based_calibration_helpers.MockDataSizes.small" href="#src.modeling.simulation_based_calibration_helpers.MockDataSizes.small">small</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.modeling.simulation_based_calibration_helpers.SBCFileManager" href="#src.modeling.simulation_based_calibration_helpers.SBCFileManager">SBCFileManager</a></code></h4>
<ul class="">
<li><code><a title="src.modeling.simulation_based_calibration_helpers.SBCFileManager.all_data_exists" href="#src.modeling.simulation_based_calibration_helpers.SBCFileManager.all_data_exists">all_data_exists</a></code></li>
<li><code><a title="src.modeling.simulation_based_calibration_helpers.SBCFileManager.get_sbc_results" href="#src.modeling.simulation_based_calibration_helpers.SBCFileManager.get_sbc_results">get_sbc_results</a></code></li>
<li><code><a title="src.modeling.simulation_based_calibration_helpers.SBCFileManager.save_sbc_results" href="#src.modeling.simulation_based_calibration_helpers.SBCFileManager.save_sbc_results">save_sbc_results</a></code></li>
<li><code><a title="src.modeling.simulation_based_calibration_helpers.SBCFileManager.sbc_results" href="#src.modeling.simulation_based_calibration_helpers.SBCFileManager.sbc_results">sbc_results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.modeling.simulation_based_calibration_helpers.SBCResults" href="#src.modeling.simulation_based_calibration_helpers.SBCResults">SBCResults</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>