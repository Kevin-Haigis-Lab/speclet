<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>speclet.data_processing.crispr API documentation</title>
<meta name="description" content="Functions for handling common modifications and processing of the Achilles data." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>speclet.data_processing.crispr</code></h1>
</header>
<section id="section-intro">
<p>Functions for handling common modifications and processing of the Achilles data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions for handling common modifications and processing of the Achilles data.&#34;&#34;&#34;

from pathlib import Path
from typing import Final, Iterable, Optional, Union

import numpy as np
import pandas as pd
from pydantic import BaseModel

from speclet.data_processing import common as dphelp
from speclet.data_processing.vectors import careful_zscore, squish_array
from speclet.io import DataFile, data_path
from speclet.loggers import logger

#### ---- Data manipulation ---- ####


def zscale_cna_by_group(
    df: pd.DataFrame,
    cn_col: str = &#34;copy_number&#34;,
    new_col: str = &#34;copy_number_z&#34;,
    groupby_cols: Optional[Union[list[str], tuple[str, ...]]] = (&#34;hugo_symbol&#34;,),
    cn_max: Optional[float] = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Z-scale the copy number values.

    Args:
        df (pd.DataFrame): The DataFrame to modify.
        cn_col (str, optional): Column with the gene copy number values.
          Defaults to &#34;copy_number&#34;.
        new_col (str, optional): The name of the column to store the calculated values.
          Defaults to &#34;copy_number_z&#34;.
        groupby_cols (Optional[Union[List[str], Tuple[str, ...]]], optional): A list or
          tuple of columns to group the DataFrame by. If None, the rows are not grouped.
          Defaults to (&#34;hugo_symbol&#34;).
        cn_max (Optional[float], optional): The maximum copy number to use.
          Defaults to None.

    Returns:
        pd.DataFrame: The modified DataFrame.
    &#34;&#34;&#34;
    if cn_max is not None and cn_max &gt; 0:
        df[new_col] = squish_array(df[cn_col].values, lower=0, upper=cn_max)
    else:
        df[new_col] = df[cn_col]

    def zscore_cna_col(d: pd.DataFrame) -&gt; pd.DataFrame:
        d[new_col] = careful_zscore(d[new_col].values)
        return d

    if groupby_cols is None:
        df = zscore_cna_col(df)
    else:
        df = df.groupby(list(groupby_cols)).apply(zscore_cna_col)

    return df


def zscale_rna_expression(
    df: pd.DataFrame,
    rna_col: str = &#34;rna_expr&#34;,
    new_col: Optional[str] = None,
    lower_bound: Optional[float] = None,
    upper_bound: Optional[float] = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Z-scale RNA expression data.

    If there is not enough variation in the values, dividing by the standard deviation
    becomes very unstable. Thus, in this function, if the values are all too similar,
    all are set to 0 instead of either `NaN` or very extreme values.

    Args:
        df (pd.DataFrame): Data frame.
        rna_col (str, optional): Column with RNA expr data. Defaults to &#34;rna_expr&#34;.
        new_col (Optional[str], optional): Name of the new column to be generated.
          Defaults to `f&#34;{rna_col}_z&#34;` if None.
        lower_bound (Optional[float], optional): Hard lower bound on the scaled values.
          Defaults to None.
        upper_bound (Optional[float], optional): Hard upper bound on the scaled values.
          Defaults to None.

    Returns:
        pd.DataFrame: The original data frame with a new column with the z-scaled RNA
          expression values.
    &#34;&#34;&#34;
    if new_col is None:
        new_col = rna_col + &#34;_z&#34;

    rna = df[rna_col].values
    rna_z = careful_zscore(rna, atol=0.01, transform=lambda x: np.log10(x + 1))

    if lower_bound is not None and upper_bound is not None:
        rna_z = squish_array(rna_z, lower=lower_bound, upper=upper_bound)

    df[new_col] = rna_z
    return df


ArgToZscaleByExpression = Union[str, Optional[str], Optional[float]]


def zscale_rna_expression_by_gene_lineage(
    df: pd.DataFrame,
    *args: ArgToZscaleByExpression,
    **kwargs: ArgToZscaleByExpression,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Z-scale RNA expression data grouping by lineage and gene.

    All positional and keyword arguments are passed to `zscale_rna_expression()`.

    Args:
        df (pd.DataFrame): The Achilles data frame.

    Returns:
        pd.DataFrame: The original data frame with a new column with the z-scaled RNA
          expression values.
    &#34;&#34;&#34;
    return df.groupby([&#34;lineage&#34;, &#34;hugo_symbol&#34;]).apply(
        zscale_rna_expression, *args, **kwargs
    )


#### ---- Indices ---- ####


def make_mapping_df(data: pd.DataFrame, col1: str, col2: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a DataFrame mapping two columns.

    Args:
        data (pd.DataFrame): The data set.
        col1 (str): The name of the column with the lower level group (group that will
          have all values appear exactly once).
        col2 (str): The name of the column with the higher level group (multiple values
          in group 1 will map to a single value in group 2).

    Returns:
        pd.DataFrame: A DataFrame mapping the values in col1 and col2.
    &#34;&#34;&#34;
    return (
        data[[col1, col2]]
        .drop_duplicates()
        .reset_index(drop=True)
        .sort_values(col1)
        .reset_index(drop=True)
    )


def make_sgrna_to_gene_mapping_df(
    data: pd.DataFrame, sgrna_col: str = &#34;sgrna&#34;, gene_col: str = &#34;hugo_symbol&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a DataFrame mapping sgRNAs to genes.

    Args:
        data (pd.DataFrame): The data set.
        sgrna_col (str, optional): The name of the column with sgRNA data. Defaults to
         &#34;sgrna&#34;.
        gene_col (str, optional): The name of the column with gene names. Defaults to
          &#34;hugo_symbol&#34;.

    Returns:
        pd.DataFrame: A DataFrame mapping sgRNAs to genes.
    &#34;&#34;&#34;
    return make_mapping_df(data, sgrna_col, gene_col)


def make_cell_line_to_lineage_mapping_df(
    data: pd.DataFrame, cell_line_col: str = &#34;depmap_id&#34;, lineage_col: str = &#34;lineage&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a DataFrame mapping cell lines to lineages.

    Args:
        data (pd.DataFrame): The data set.
        cell_line_col (str, optional): The name of the column with cell line names.
          Defaults to &#34;depmap_id&#34;.
        lineage_col (str, optional): The name of the column with lineages. Defaults to
          &#34;lineage&#34;.

    Returns:
        pd.DataFrame: A DataFrame mapping cell lines to lineages.
    &#34;&#34;&#34;
    return make_mapping_df(data, cell_line_col, lineage_col)


def make_kras_mutation_index_with_other(
    df: pd.DataFrame,
    min: int = 0,
    kras_col: str = &#34;kras_mutation&#34;,
    cl_col: str = &#34;depmap_id&#34;,
) -&gt; np.ndarray:
    &#34;&#34;&#34;KRAS indexing with other for rare mutations.

    Args:
        df (pd.DataFrame): Data frame to make index for.
        min (int, optional): Minimim number of cell lines with the mutation to keep it
          as a separate group. Defaults to 0.
        kras_col (str, optional): Column name with KRAS mutations. Defaults to
          &#34;kras_mutation&#34;.
        cl_col (str, optional): Column name with cell line identifiers. Defaults to
          &#34;depmap_id&#34;.

    Raises:
        ValueError: Raised if the indicated columns do not exist.

    Returns:
        np.ndarray: Index for KRAS alleles.
    &#34;&#34;&#34;
    for col in (kras_col, cl_col):
        if col not in df.columns:
            raise ValueError(f&#34;Could not find column &#39;{col}&#39; in data frame.&#34;)
    kg = &#34;__kras_group&#34;
    mut_freq = (
        df[[kras_col, cl_col]]
        .drop_duplicates()
        .groupby(kras_col)[[cl_col]]
        .count()
        .reset_index(drop=False)
    )
    mut_freq[kg] = [
        k if n &gt;= min else &#34;__other__&#34;
        for k, n in zip(mut_freq[kras_col], mut_freq[cl_col])
    ]
    mut_freq = mut_freq[[kras_col, kg]]
    return (
        pd.merge(df.copy(), mut_freq, how=&#34;left&#34;, on=kras_col)
        .pipe(dphelp.make_cat, col=kg, sort_cats=True)
        .pipe(dphelp.get_indices, col=kg)
    )


class CommonIndices(BaseModel):
    &#34;&#34;&#34;Object to hold common indices used for modeling Achilles data.&#34;&#34;&#34;

    sgrna_idx: np.ndarray
    n_sgrnas: int = 0
    sgrna_to_gene_map: pd.DataFrame
    sgrna_to_gene_idx: np.ndarray
    gene_idx: np.ndarray
    n_genes: int = 0
    cellline_idx: np.ndarray
    n_celllines: int = 0
    lineage_idx: np.ndarray
    n_lineages: int = 0
    cellline_to_lineage_map: pd.DataFrame
    cellline_to_lineage_idx: np.ndarray

    def __init__(self, **data: Union[int, np.ndarray, pd.DataFrame]):
        &#34;&#34;&#34;Object to hold common indices used for modeling Achilles data.&#34;&#34;&#34;
        super().__init__(**data)
        self.n_sgrnas = dphelp.nunique(self.sgrna_idx)
        self.n_genes = dphelp.nunique(self.gene_idx)
        self.n_celllines = dphelp.nunique(self.cellline_idx)
        self.n_lineages = dphelp.nunique(self.lineage_idx)

    class Config:
        &#34;&#34;&#34;Configuration for pydantic validation.&#34;&#34;&#34;

        arbitrary_types_allowed = True


def common_indices(achilles_df: pd.DataFrame) -&gt; CommonIndices:
    &#34;&#34;&#34;Generate a collection of indices frequently used when modeling the Achilles data.

    Args:
        achilles_df (pd.DataFrame): The DataFrame with Achilles data.

    Returns:
        CommonIndices: A data model with a collection of indices.
    &#34;&#34;&#34;
    sgrna_to_gene_map = make_sgrna_to_gene_mapping_df(achilles_df)
    cellline_to_lineage_map = make_cell_line_to_lineage_mapping_df(achilles_df)
    return CommonIndices(
        sgrna_idx=dphelp.get_indices(achilles_df, &#34;sgrna&#34;),
        sgrna_to_gene_map=sgrna_to_gene_map,
        sgrna_to_gene_idx=dphelp.get_indices(sgrna_to_gene_map, &#34;hugo_symbol&#34;),
        gene_idx=dphelp.get_indices(achilles_df, &#34;hugo_symbol&#34;),
        cellline_idx=dphelp.get_indices(achilles_df, &#34;depmap_id&#34;),
        lineage_idx=dphelp.get_indices(achilles_df, &#34;lineage&#34;),
        cellline_to_lineage_map=cellline_to_lineage_map,
        cellline_to_lineage_idx=dphelp.get_indices(cellline_to_lineage_map, &#34;lineage&#34;),
        batch_idx=dphelp.get_indices(achilles_df, &#34;p_dna_batch&#34;),
    )


class DataBatchIndices(BaseModel):
    &#34;&#34;&#34;Object to hold indices relating to data screens and batches.&#34;&#34;&#34;

    batch_idx: np.ndarray
    n_batches: int = 0
    screen_idx: np.ndarray
    n_screens: int = 0
    batch_to_screen_map: pd.DataFrame
    batch_to_screen_idx: np.ndarray

    def __init__(self, **data: Union[int, np.ndarray, pd.DataFrame]):
        &#34;&#34;&#34;Object to hold indices relating to data screens and batches.&#34;&#34;&#34;
        super().__init__(**data)
        self.n_batches = dphelp.nunique(self.batch_idx)
        self.n_screens = dphelp.nunique(self.screen_idx)

    class Config:
        &#34;&#34;&#34;Configuration for pydantic validation.&#34;&#34;&#34;

        arbitrary_types_allowed = True


def data_batch_indices(achilles_df: pd.DataFrame) -&gt; DataBatchIndices:
    &#34;&#34;&#34;Generate a collection of indices relating to data screens and batches.

    Args:
        achilles_df (pd.DataFrame): The DataFrame with Achilles data.

    Returns:
        DataBatchIndices: A data model with a collection of indices.
    &#34;&#34;&#34;
    batch_to_screen_map = make_mapping_df(
        achilles_df, col1=&#34;p_dna_batch&#34;, col2=&#34;screen&#34;
    )
    return DataBatchIndices(
        batch_idx=dphelp.get_indices(achilles_df, &#34;p_dna_batch&#34;),
        screen_idx=dphelp.get_indices(achilles_df, &#34;screen&#34;),
        batch_to_screen_map=batch_to_screen_map,
        batch_to_screen_idx=dphelp.get_indices(batch_to_screen_map, &#34;screen&#34;),
    )


#### ---- Data frames ---- ####

_default_achilles_categorical_cols: Final[tuple[str, ...]] = (
    &#34;hugo_symbol&#34;,
    &#34;depmap_id&#34;,
    &#34;sgrna&#34;,
    &#34;lineage&#34;,
    &#34;sgrna_target_chr&#34;,
    &#34;p_dna_batch&#34;,
    &#34;screen&#34;,
)


def set_achilles_categorical_columns(
    data: pd.DataFrame,
    cols: Iterable[str] = _default_achilles_categorical_cols,
    ordered: bool = True,
    sort_cats: bool = False,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Set the appropriate columns of the Achilles data as factors.

    If the column is not actually in the data frame, it is just skipped.

    Args:
        data (pd.DataFrame): Achilles DataFrame.
        cols (Union[List[str], Tuple[str, ...]], optional): The names of the columns to
          make categorical. Defaults to (&#34;hugo_symbol&#34;, &#34;depmap_id&#34;, &#34;sgrna&#34;,
          &#34;lineage&#34;, &#34;sgrna_target_chr&#34;, &#34;p_dna_batch&#34;, &#34;screen&#34;).
        ordered (bool, optional): Should the categorical columns be ordered?
          Defaults to True.
        sort_cats (bool, optional): Should the categorical columns be sorted?
          Defaults to False.

    Returns:
        pd.DataFrame: The modified DataFrame.
    &#34;&#34;&#34;
    for col in cols:
        if col in data.columns:
            data = dphelp.make_cat(data, col, ordered=ordered, sort_cats=sort_cats)
    return data


def sort_achilles_data(data: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Sort a CRISPR screen data frame.

    Args:
        data (pd.DataFrame): CRISPR screen data frame.

    Returns:
        pd.DataFrame: Sorted data frame.
    &#34;&#34;&#34;
    return data.sort_values(
        [&#34;hugo_symbol&#34;, &#34;sgrna&#34;, &#34;lineage&#34;, &#34;depmap_id&#34;]
    ).reset_index(drop=True)


def read_achilles_data(
    data_path: Path, low_memory: bool = True, set_categorical_cols: bool = True
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Read in an Achilles data set.

    Args:
        data_path (Path): The path to the data set.
        low_memory (bool, optional): Should pandas be informed of memory constraints?
          Defaults to True.
        set_categorical_cols (bool, optional): Should the default categorical columns
          be set? Defaults to True.

    Returns:
        pd.DataFrame: The Achilles data set.
    &#34;&#34;&#34;
    data = pd.read_csv(data_path, low_memory=low_memory).pipe(sort_achilles_data)

    if set_categorical_cols:
        data = set_achilles_categorical_columns(data)

    return data


def subsample_achilles_data(
    df: pd.DataFrame, n_genes: Optional[int] = 100, n_cell_lines: Optional[int] = None
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Subsample an Achilles data set to a number of genes and/or cell lines.

    Args:
        df (pd.DataFrame): Achilles data.
        n_genes (Optional[int], optional): Number of genes to subsample.
          Defaults to 100.
        n_cell_lines (Optional[int], optional): Number of cell lines to subsample.
          Defaults to None.

    Raises:
        ValueError: If the number of genes or cell lines is not positive.

    Returns:
        pd.DataFrame: The Achilles data set.
    &#34;&#34;&#34;
    if n_genes is not None and n_genes &lt;= 0:
        raise ValueError(&#34;Number of genes must be positive.&#34;)
    if n_cell_lines is not None and n_cell_lines &lt;= 0:
        raise ValueError(&#34;Number of cell lines must be positive.&#34;)

    genes: np.ndarray = df.hugo_symbol.unique()
    cell_lines: np.ndarray = df.depmap_id.unique()

    if n_genes is not None:
        genes = np.random.choice(genes, n_genes, replace=False)

    if n_cell_lines is not None:
        cell_lines = np.random.choice(cell_lines, n_cell_lines, replace=False)

    sub_df: pd.DataFrame = df.copy()
    sub_df = sub_df[sub_df.hugo_symbol.isin(genes)]
    sub_df = sub_df[sub_df.depmap_id.isin(cell_lines)]
    return sub_df


def append_total_read_counts(
    achilles_df: pd.DataFrame,
    final_reads_total: Optional[Path] = None,
    p_dna_reads_total: Optional[Path] = None,
    final_reads_total_colname: str = &#34;counts_final_total&#34;,
    initial_reads_total_colname: str = &#34;counts_initial_total&#34;,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Append columns with total read count data.

    Args:
        achilles_df (pd.DataFrame): Achilles data frame.
        final_reads_total (Optional[Path], optional): Path to the final read totals
          table (as a CSV). Defaults to None.
        p_dna_reads_total (Optional[Path], optional): Path to the initial read totals
          table (as a CSV). Defaults to None.
        final_reads_total_colname (str, optional): Name for the column with the total
          number of final read counts. Defaults to &#34;counts_final_total&#34;.
        initial_reads_total_colname (str, optional): Name for the column with the total
          number of initial read counts. Defaults to &#34;counts_initial_total&#34;.

    Returns:
        pd.DataFrame: The initial data frame with two new columns.
    &#34;&#34;&#34;
    if final_reads_total is None:
        final_reads_total = data_path(DataFile.SCREEN_READ_COUNT_TOTALS)
    if p_dna_reads_total is None:
        p_dna_reads_total = data_path(DataFile.PDNA_READ_COUNT_TOTALS)

    final_reads_total_df = pd.read_csv(final_reads_total)
    p_dna_reads_total_df = pd.read_csv(p_dna_reads_total)

    return (
        achilles_df.merge(final_reads_total_df, on=&#34;replicate_id&#34;)
        .rename(columns={&#34;total_reads&#34;: final_reads_total_colname})
        .merge(p_dna_reads_total_df, on=&#34;p_dna_batch&#34;)
        .rename(columns={&#34;total_reads&#34;: initial_reads_total_colname})
    )


def add_useful_read_count_columns(
    crispr_df: pd.DataFrame,
    counts_final: str = &#34;counts_final&#34;,
    counts_final_total: str = &#34;counts_final_total&#34;,
    counts_initial: str = &#34;counts_initial&#34;,
    counts_initial_total: str = &#34;counts_initial_total&#34;,
    counts_final_rpm: str = &#34;counts_final_rpm&#34;,
    counts_initial_adj: str = &#34;counts_initial_adj&#34;,
    copy: bool = False,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Add some useful columns for modeling read count data.

    - final counts RPM =
      \\(1^6 \\times (c_\\text{final} / \\Sigma c_\\text{final}) + 1\\)
    - adjusted initial counts = \\((c_\\text{initial} / \\Sigma c_\\text{initial})
      \\times \\Sigma c_\\text{final}\\)

    Args:
        crispr_df (pd.DataFrame): Achilles data frame
        counts_final (str, optional): Column of final read counts. Defaults to
          &#34;counts_final&#34;.
        counts_final_total (str, optional): Column of total final read counts. Defaults
          to &#34;counts_final_total&#34;.
        counts_initial (str, optional): Column of initial read counts. Defaults to
          &#34;counts_initial&#34;.
        counts_initial_total (str, optional): Column of total initial read counts.
          Defaults to &#34;counts_initial_total&#34;.
        counts_final_rpm (str, optional): Column name for the new column with the final
          read counts in &#34;reads per million&#34; (RPM). Defaults to &#34;counts_final_rpm&#34;.
        counts_initial_adj (str, optional): Column name for the new column with the
          adjusted initial read counts. Defaults to &#34;counts_initial_adj&#34;.
        copy (bool, optional): First copy the data frame? Defaults to False.

    Returns:
        pd.DataFrame: The original data frame with the new columns append.
    &#34;&#34;&#34;
    if copy:
        crispr_df = crispr_df.copy()

    # 1e6 * (counts_f / Σ counts_f) + 1
    crispr_df[counts_final_rpm] = (
        1e6 * (crispr_df[counts_final] / crispr_df[counts_final_total]) + 1
    )
    # (counts_i / Σ counts_i) * Σ counts_f
    crispr_df[counts_initial_adj] = (
        crispr_df[counts_initial] / crispr_df[counts_initial_total]
    ) * crispr_df[counts_final_total]

    return crispr_df


def filter_for_broad_source_only(
    df: pd.DataFrame, screen_col: str = &#34;screen&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Filter for only data from the Broad.

    Args:
        df (pd.DataFrame): CRISPR screen data.
        screen_col (str, optional): Name of the column indicating the origin of the
          data. Defaults to &#34;screen&#34;.

    Returns:
        pd.DataFrame: The filtered data frame.
    &#34;&#34;&#34;
    return df[df[screen_col] == &#34;broad&#34;].reset_index(drop=True)


def _get_sgrnas_that_map_to_multiple_genes(
    df: pd.DataFrame, sgrna_col: str
) -&gt; np.ndarray:
    return (
        make_sgrna_to_gene_mapping_df(df)
        .groupby([sgrna_col])[&#34;hugo_symbol&#34;]
        .count()
        .reset_index()
        .query(&#34;hugo_symbol &gt; 1&#34;)[sgrna_col]
        .unique()
    )


def drop_sgrnas_that_map_to_multiple_genes(
    df: pd.DataFrame, sgrna_col: str = &#34;sgrna&#34;, gene_col: str = &#34;hugo_symbol&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Drop sgRNAs that map to multiple genes.

    Because of how the multi-hitting sgRNAs are identified, this function in not
    &#34;Dask friendly.&#34;

    Args:
        df (pd.DataFrame): CRISPR screen data frame.
        sgrna_col (str, optional): sgRNA column name. Defaults to &#34;sgrna&#34;.
        gene_col (str, optional): Gene column name. Defaults to &#34;hugo_symbol&#34;.

    Returns:
        pd.DataFrame: The filtered data frame.
    &#34;&#34;&#34;
    sgrnas_to_remove = _get_sgrnas_that_map_to_multiple_genes(df, sgrna_col)
    logger.warning(
        f&#34;Dropping {len(sgrnas_to_remove)} sgRNA that map to multiple genes.&#34;
    )
    df_new = df.copy()[~df[sgrna_col].isin(sgrnas_to_remove)]
    return df_new


def drop_missing_copynumber(
    df: pd.DataFrame, cn_col: str = &#34;copy_number&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;From data points with missing copy number data.

    Args:
        df (pd.DataFrame): CRISPR screen data.
        cn_col (str, optional): Name of the column with copy number data. Defaults to
          &#34;copy_number&#34;.

    Returns:
        pd.DataFrame: Filtered data frame.
    &#34;&#34;&#34;
    df_new = df.copy()[~df[cn_col].isna()]
    size_diff = df.shape[0] - df_new.shape[0]
    logger.warning(f&#34;Dropping {size_diff} data points with missing copy number.&#34;)
    return df_new</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="speclet.data_processing.crispr.add_useful_read_count_columns"><code class="name flex">
<span>def <span class="ident">add_useful_read_count_columns</span></span>(<span>crispr_df: pandas.core.frame.DataFrame, counts_final: str = 'counts_final', counts_final_total: str = 'counts_final_total', counts_initial: str = 'counts_initial', counts_initial_total: str = 'counts_initial_total', counts_final_rpm: str = 'counts_final_rpm', counts_initial_adj: str = 'counts_initial_adj', copy: bool = False) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Add some useful columns for modeling read count data.</p>
<ul>
<li>final counts RPM =
<span><span class="MathJax_Preview">1^6 \times (c_\text{final} / \Sigma c_\text{final}) + 1</span><script type="math/tex">1^6 \times (c_\text{final} / \Sigma c_\text{final}) + 1</script></span></li>
<li>adjusted initial counts = <span><span class="MathJax_Preview">(c_\text{initial} / \Sigma c_\text{initial})
\times \Sigma c_\text{final}</span><script type="math/tex">(c_\text{initial} / \Sigma c_\text{initial})
\times \Sigma c_\text{final}</script></span></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>crispr_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Achilles data frame</dd>
<dt><strong><code>counts_final</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column of final read counts. Defaults to
"counts_final".</dd>
<dt><strong><code>counts_final_total</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column of total final read counts. Defaults
to "counts_final_total".</dd>
<dt><strong><code>counts_initial</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column of initial read counts. Defaults to
"counts_initial".</dd>
<dt><strong><code>counts_initial_total</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column of total initial read counts.
Defaults to "counts_initial_total".</dd>
<dt><strong><code>counts_final_rpm</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column name for the new column with the final
read counts in "reads per million" (RPM). Defaults to "counts_final_rpm".</dd>
<dt><strong><code>counts_initial_adj</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column name for the new column with the
adjusted initial read counts. Defaults to "counts_initial_adj".</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>First copy the data frame? Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The original data frame with the new columns append.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_useful_read_count_columns(
    crispr_df: pd.DataFrame,
    counts_final: str = &#34;counts_final&#34;,
    counts_final_total: str = &#34;counts_final_total&#34;,
    counts_initial: str = &#34;counts_initial&#34;,
    counts_initial_total: str = &#34;counts_initial_total&#34;,
    counts_final_rpm: str = &#34;counts_final_rpm&#34;,
    counts_initial_adj: str = &#34;counts_initial_adj&#34;,
    copy: bool = False,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Add some useful columns for modeling read count data.

    - final counts RPM =
      \\(1^6 \\times (c_\\text{final} / \\Sigma c_\\text{final}) + 1\\)
    - adjusted initial counts = \\((c_\\text{initial} / \\Sigma c_\\text{initial})
      \\times \\Sigma c_\\text{final}\\)

    Args:
        crispr_df (pd.DataFrame): Achilles data frame
        counts_final (str, optional): Column of final read counts. Defaults to
          &#34;counts_final&#34;.
        counts_final_total (str, optional): Column of total final read counts. Defaults
          to &#34;counts_final_total&#34;.
        counts_initial (str, optional): Column of initial read counts. Defaults to
          &#34;counts_initial&#34;.
        counts_initial_total (str, optional): Column of total initial read counts.
          Defaults to &#34;counts_initial_total&#34;.
        counts_final_rpm (str, optional): Column name for the new column with the final
          read counts in &#34;reads per million&#34; (RPM). Defaults to &#34;counts_final_rpm&#34;.
        counts_initial_adj (str, optional): Column name for the new column with the
          adjusted initial read counts. Defaults to &#34;counts_initial_adj&#34;.
        copy (bool, optional): First copy the data frame? Defaults to False.

    Returns:
        pd.DataFrame: The original data frame with the new columns append.
    &#34;&#34;&#34;
    if copy:
        crispr_df = crispr_df.copy()

    # 1e6 * (counts_f / Σ counts_f) + 1
    crispr_df[counts_final_rpm] = (
        1e6 * (crispr_df[counts_final] / crispr_df[counts_final_total]) + 1
    )
    # (counts_i / Σ counts_i) * Σ counts_f
    crispr_df[counts_initial_adj] = (
        crispr_df[counts_initial] / crispr_df[counts_initial_total]
    ) * crispr_df[counts_final_total]

    return crispr_df</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.append_total_read_counts"><code class="name flex">
<span>def <span class="ident">append_total_read_counts</span></span>(<span>achilles_df: pandas.core.frame.DataFrame, final_reads_total: Optional[pathlib.Path] = None, p_dna_reads_total: Optional[pathlib.Path] = None, final_reads_total_colname: str = 'counts_final_total', initial_reads_total_colname: str = 'counts_initial_total') -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Append columns with total read count data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>achilles_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Achilles data frame.</dd>
<dt><strong><code>final_reads_total</code></strong> :&ensp;<code>Optional[Path]</code>, optional</dt>
<dd>Path to the final read totals
table (as a CSV). Defaults to None.</dd>
<dt><strong><code>p_dna_reads_total</code></strong> :&ensp;<code>Optional[Path]</code>, optional</dt>
<dd>Path to the initial read totals
table (as a CSV). Defaults to None.</dd>
<dt><strong><code>final_reads_total_colname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for the column with the total
number of final read counts. Defaults to "counts_final_total".</dd>
<dt><strong><code>initial_reads_total_colname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for the column with the total
number of initial read counts. Defaults to "counts_initial_total".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The initial data frame with two new columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_total_read_counts(
    achilles_df: pd.DataFrame,
    final_reads_total: Optional[Path] = None,
    p_dna_reads_total: Optional[Path] = None,
    final_reads_total_colname: str = &#34;counts_final_total&#34;,
    initial_reads_total_colname: str = &#34;counts_initial_total&#34;,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Append columns with total read count data.

    Args:
        achilles_df (pd.DataFrame): Achilles data frame.
        final_reads_total (Optional[Path], optional): Path to the final read totals
          table (as a CSV). Defaults to None.
        p_dna_reads_total (Optional[Path], optional): Path to the initial read totals
          table (as a CSV). Defaults to None.
        final_reads_total_colname (str, optional): Name for the column with the total
          number of final read counts. Defaults to &#34;counts_final_total&#34;.
        initial_reads_total_colname (str, optional): Name for the column with the total
          number of initial read counts. Defaults to &#34;counts_initial_total&#34;.

    Returns:
        pd.DataFrame: The initial data frame with two new columns.
    &#34;&#34;&#34;
    if final_reads_total is None:
        final_reads_total = data_path(DataFile.SCREEN_READ_COUNT_TOTALS)
    if p_dna_reads_total is None:
        p_dna_reads_total = data_path(DataFile.PDNA_READ_COUNT_TOTALS)

    final_reads_total_df = pd.read_csv(final_reads_total)
    p_dna_reads_total_df = pd.read_csv(p_dna_reads_total)

    return (
        achilles_df.merge(final_reads_total_df, on=&#34;replicate_id&#34;)
        .rename(columns={&#34;total_reads&#34;: final_reads_total_colname})
        .merge(p_dna_reads_total_df, on=&#34;p_dna_batch&#34;)
        .rename(columns={&#34;total_reads&#34;: initial_reads_total_colname})
    )</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.common_indices"><code class="name flex">
<span>def <span class="ident">common_indices</span></span>(<span>achilles_df: pandas.core.frame.DataFrame) -> <a title="speclet.data_processing.crispr.CommonIndices" href="#speclet.data_processing.crispr.CommonIndices">CommonIndices</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate a collection of indices frequently used when modeling the Achilles data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>achilles_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The DataFrame with Achilles data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="speclet.data_processing.crispr.CommonIndices" href="#speclet.data_processing.crispr.CommonIndices">CommonIndices</a></code></dt>
<dd>A data model with a collection of indices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def common_indices(achilles_df: pd.DataFrame) -&gt; CommonIndices:
    &#34;&#34;&#34;Generate a collection of indices frequently used when modeling the Achilles data.

    Args:
        achilles_df (pd.DataFrame): The DataFrame with Achilles data.

    Returns:
        CommonIndices: A data model with a collection of indices.
    &#34;&#34;&#34;
    sgrna_to_gene_map = make_sgrna_to_gene_mapping_df(achilles_df)
    cellline_to_lineage_map = make_cell_line_to_lineage_mapping_df(achilles_df)
    return CommonIndices(
        sgrna_idx=dphelp.get_indices(achilles_df, &#34;sgrna&#34;),
        sgrna_to_gene_map=sgrna_to_gene_map,
        sgrna_to_gene_idx=dphelp.get_indices(sgrna_to_gene_map, &#34;hugo_symbol&#34;),
        gene_idx=dphelp.get_indices(achilles_df, &#34;hugo_symbol&#34;),
        cellline_idx=dphelp.get_indices(achilles_df, &#34;depmap_id&#34;),
        lineage_idx=dphelp.get_indices(achilles_df, &#34;lineage&#34;),
        cellline_to_lineage_map=cellline_to_lineage_map,
        cellline_to_lineage_idx=dphelp.get_indices(cellline_to_lineage_map, &#34;lineage&#34;),
        batch_idx=dphelp.get_indices(achilles_df, &#34;p_dna_batch&#34;),
    )</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.data_batch_indices"><code class="name flex">
<span>def <span class="ident">data_batch_indices</span></span>(<span>achilles_df: pandas.core.frame.DataFrame) -> <a title="speclet.data_processing.crispr.DataBatchIndices" href="#speclet.data_processing.crispr.DataBatchIndices">DataBatchIndices</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate a collection of indices relating to data screens and batches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>achilles_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The DataFrame with Achilles data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="speclet.data_processing.crispr.DataBatchIndices" href="#speclet.data_processing.crispr.DataBatchIndices">DataBatchIndices</a></code></dt>
<dd>A data model with a collection of indices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_batch_indices(achilles_df: pd.DataFrame) -&gt; DataBatchIndices:
    &#34;&#34;&#34;Generate a collection of indices relating to data screens and batches.

    Args:
        achilles_df (pd.DataFrame): The DataFrame with Achilles data.

    Returns:
        DataBatchIndices: A data model with a collection of indices.
    &#34;&#34;&#34;
    batch_to_screen_map = make_mapping_df(
        achilles_df, col1=&#34;p_dna_batch&#34;, col2=&#34;screen&#34;
    )
    return DataBatchIndices(
        batch_idx=dphelp.get_indices(achilles_df, &#34;p_dna_batch&#34;),
        screen_idx=dphelp.get_indices(achilles_df, &#34;screen&#34;),
        batch_to_screen_map=batch_to_screen_map,
        batch_to_screen_idx=dphelp.get_indices(batch_to_screen_map, &#34;screen&#34;),
    )</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.drop_missing_copynumber"><code class="name flex">
<span>def <span class="ident">drop_missing_copynumber</span></span>(<span>df: pandas.core.frame.DataFrame, cn_col: str = 'copy_number') -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>From data points with missing copy number data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>CRISPR screen data.</dd>
<dt><strong><code>cn_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the column with copy number data. Defaults to
"copy_number".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Filtered data frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_missing_copynumber(
    df: pd.DataFrame, cn_col: str = &#34;copy_number&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;From data points with missing copy number data.

    Args:
        df (pd.DataFrame): CRISPR screen data.
        cn_col (str, optional): Name of the column with copy number data. Defaults to
          &#34;copy_number&#34;.

    Returns:
        pd.DataFrame: Filtered data frame.
    &#34;&#34;&#34;
    df_new = df.copy()[~df[cn_col].isna()]
    size_diff = df.shape[0] - df_new.shape[0]
    logger.warning(f&#34;Dropping {size_diff} data points with missing copy number.&#34;)
    return df_new</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.drop_sgrnas_that_map_to_multiple_genes"><code class="name flex">
<span>def <span class="ident">drop_sgrnas_that_map_to_multiple_genes</span></span>(<span>df: pandas.core.frame.DataFrame, sgrna_col: str = 'sgrna', gene_col: str = 'hugo_symbol') -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Drop sgRNAs that map to multiple genes.</p>
<p>Because of how the multi-hitting sgRNAs are identified, this function in not
"Dask friendly."</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>CRISPR screen data frame.</dd>
<dt><strong><code>sgrna_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>sgRNA column name. Defaults to "sgrna".</dd>
<dt><strong><code>gene_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Gene column name. Defaults to "hugo_symbol".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The filtered data frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_sgrnas_that_map_to_multiple_genes(
    df: pd.DataFrame, sgrna_col: str = &#34;sgrna&#34;, gene_col: str = &#34;hugo_symbol&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Drop sgRNAs that map to multiple genes.

    Because of how the multi-hitting sgRNAs are identified, this function in not
    &#34;Dask friendly.&#34;

    Args:
        df (pd.DataFrame): CRISPR screen data frame.
        sgrna_col (str, optional): sgRNA column name. Defaults to &#34;sgrna&#34;.
        gene_col (str, optional): Gene column name. Defaults to &#34;hugo_symbol&#34;.

    Returns:
        pd.DataFrame: The filtered data frame.
    &#34;&#34;&#34;
    sgrnas_to_remove = _get_sgrnas_that_map_to_multiple_genes(df, sgrna_col)
    logger.warning(
        f&#34;Dropping {len(sgrnas_to_remove)} sgRNA that map to multiple genes.&#34;
    )
    df_new = df.copy()[~df[sgrna_col].isin(sgrnas_to_remove)]
    return df_new</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.filter_for_broad_source_only"><code class="name flex">
<span>def <span class="ident">filter_for_broad_source_only</span></span>(<span>df: pandas.core.frame.DataFrame, screen_col: str = 'screen') -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Filter for only data from the Broad.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>CRISPR screen data.</dd>
<dt><strong><code>screen_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the column indicating the origin of the
data. Defaults to "screen".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The filtered data frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_for_broad_source_only(
    df: pd.DataFrame, screen_col: str = &#34;screen&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Filter for only data from the Broad.

    Args:
        df (pd.DataFrame): CRISPR screen data.
        screen_col (str, optional): Name of the column indicating the origin of the
          data. Defaults to &#34;screen&#34;.

    Returns:
        pd.DataFrame: The filtered data frame.
    &#34;&#34;&#34;
    return df[df[screen_col] == &#34;broad&#34;].reset_index(drop=True)</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.make_cell_line_to_lineage_mapping_df"><code class="name flex">
<span>def <span class="ident">make_cell_line_to_lineage_mapping_df</span></span>(<span>data: pandas.core.frame.DataFrame, cell_line_col: str = 'depmap_id', lineage_col: str = 'lineage') -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a DataFrame mapping cell lines to lineages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The data set.</dd>
<dt><strong><code>cell_line_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the column with cell line names.
Defaults to "depmap_id".</dd>
<dt><strong><code>lineage_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the column with lineages. Defaults to
"lineage".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame mapping cell lines to lineages.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_cell_line_to_lineage_mapping_df(
    data: pd.DataFrame, cell_line_col: str = &#34;depmap_id&#34;, lineage_col: str = &#34;lineage&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a DataFrame mapping cell lines to lineages.

    Args:
        data (pd.DataFrame): The data set.
        cell_line_col (str, optional): The name of the column with cell line names.
          Defaults to &#34;depmap_id&#34;.
        lineage_col (str, optional): The name of the column with lineages. Defaults to
          &#34;lineage&#34;.

    Returns:
        pd.DataFrame: A DataFrame mapping cell lines to lineages.
    &#34;&#34;&#34;
    return make_mapping_df(data, cell_line_col, lineage_col)</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.make_kras_mutation_index_with_other"><code class="name flex">
<span>def <span class="ident">make_kras_mutation_index_with_other</span></span>(<span>df: pandas.core.frame.DataFrame, min: int = 0, kras_col: str = 'kras_mutation', cl_col: str = 'depmap_id') -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>KRAS indexing with other for rare mutations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Data frame to make index for.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Minimim number of cell lines with the mutation to keep it
as a separate group. Defaults to 0.</dd>
<dt><strong><code>kras_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column name with KRAS mutations. Defaults to
"kras_mutation".</dd>
<dt><strong><code>cl_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column name with cell line identifiers. Defaults to
"depmap_id".</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised if the indicated columns do not exist.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Index for KRAS alleles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_kras_mutation_index_with_other(
    df: pd.DataFrame,
    min: int = 0,
    kras_col: str = &#34;kras_mutation&#34;,
    cl_col: str = &#34;depmap_id&#34;,
) -&gt; np.ndarray:
    &#34;&#34;&#34;KRAS indexing with other for rare mutations.

    Args:
        df (pd.DataFrame): Data frame to make index for.
        min (int, optional): Minimim number of cell lines with the mutation to keep it
          as a separate group. Defaults to 0.
        kras_col (str, optional): Column name with KRAS mutations. Defaults to
          &#34;kras_mutation&#34;.
        cl_col (str, optional): Column name with cell line identifiers. Defaults to
          &#34;depmap_id&#34;.

    Raises:
        ValueError: Raised if the indicated columns do not exist.

    Returns:
        np.ndarray: Index for KRAS alleles.
    &#34;&#34;&#34;
    for col in (kras_col, cl_col):
        if col not in df.columns:
            raise ValueError(f&#34;Could not find column &#39;{col}&#39; in data frame.&#34;)
    kg = &#34;__kras_group&#34;
    mut_freq = (
        df[[kras_col, cl_col]]
        .drop_duplicates()
        .groupby(kras_col)[[cl_col]]
        .count()
        .reset_index(drop=False)
    )
    mut_freq[kg] = [
        k if n &gt;= min else &#34;__other__&#34;
        for k, n in zip(mut_freq[kras_col], mut_freq[cl_col])
    ]
    mut_freq = mut_freq[[kras_col, kg]]
    return (
        pd.merge(df.copy(), mut_freq, how=&#34;left&#34;, on=kras_col)
        .pipe(dphelp.make_cat, col=kg, sort_cats=True)
        .pipe(dphelp.get_indices, col=kg)
    )</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.make_mapping_df"><code class="name flex">
<span>def <span class="ident">make_mapping_df</span></span>(<span>data: pandas.core.frame.DataFrame, col1: str, col2: str) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a DataFrame mapping two columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The data set.</dd>
<dt><strong><code>col1</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the column with the lower level group (group that will
have all values appear exactly once).</dd>
<dt><strong><code>col2</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the column with the higher level group (multiple values
in group 1 will map to a single value in group 2).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame mapping the values in col1 and col2.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_mapping_df(data: pd.DataFrame, col1: str, col2: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a DataFrame mapping two columns.

    Args:
        data (pd.DataFrame): The data set.
        col1 (str): The name of the column with the lower level group (group that will
          have all values appear exactly once).
        col2 (str): The name of the column with the higher level group (multiple values
          in group 1 will map to a single value in group 2).

    Returns:
        pd.DataFrame: A DataFrame mapping the values in col1 and col2.
    &#34;&#34;&#34;
    return (
        data[[col1, col2]]
        .drop_duplicates()
        .reset_index(drop=True)
        .sort_values(col1)
        .reset_index(drop=True)
    )</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.make_sgrna_to_gene_mapping_df"><code class="name flex">
<span>def <span class="ident">make_sgrna_to_gene_mapping_df</span></span>(<span>data: pandas.core.frame.DataFrame, sgrna_col: str = 'sgrna', gene_col: str = 'hugo_symbol') -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a DataFrame mapping sgRNAs to genes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The data set.</dd>
<dt><strong><code>sgrna_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the column with sgRNA data. Defaults to</dd>
<dt>"sgrna".</dt>
<dt><strong><code>gene_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the column with gene names. Defaults to
"hugo_symbol".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame mapping sgRNAs to genes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_sgrna_to_gene_mapping_df(
    data: pd.DataFrame, sgrna_col: str = &#34;sgrna&#34;, gene_col: str = &#34;hugo_symbol&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a DataFrame mapping sgRNAs to genes.

    Args:
        data (pd.DataFrame): The data set.
        sgrna_col (str, optional): The name of the column with sgRNA data. Defaults to
         &#34;sgrna&#34;.
        gene_col (str, optional): The name of the column with gene names. Defaults to
          &#34;hugo_symbol&#34;.

    Returns:
        pd.DataFrame: A DataFrame mapping sgRNAs to genes.
    &#34;&#34;&#34;
    return make_mapping_df(data, sgrna_col, gene_col)</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.read_achilles_data"><code class="name flex">
<span>def <span class="ident">read_achilles_data</span></span>(<span>data_path: pathlib.Path, low_memory: bool = True, set_categorical_cols: bool = True) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Read in an Achilles data set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The path to the data set.</dd>
<dt><strong><code>low_memory</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should pandas be informed of memory constraints?
Defaults to True.</dd>
<dt><strong><code>set_categorical_cols</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the default categorical columns
be set? Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The Achilles data set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_achilles_data(
    data_path: Path, low_memory: bool = True, set_categorical_cols: bool = True
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Read in an Achilles data set.

    Args:
        data_path (Path): The path to the data set.
        low_memory (bool, optional): Should pandas be informed of memory constraints?
          Defaults to True.
        set_categorical_cols (bool, optional): Should the default categorical columns
          be set? Defaults to True.

    Returns:
        pd.DataFrame: The Achilles data set.
    &#34;&#34;&#34;
    data = pd.read_csv(data_path, low_memory=low_memory).pipe(sort_achilles_data)

    if set_categorical_cols:
        data = set_achilles_categorical_columns(data)

    return data</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.set_achilles_categorical_columns"><code class="name flex">
<span>def <span class="ident">set_achilles_categorical_columns</span></span>(<span>data: pandas.core.frame.DataFrame, cols: Iterable[str] = ('hugo_symbol', 'depmap_id', 'sgrna', 'lineage', 'sgrna_target_chr', 'p_dna_batch', 'screen'), ordered: bool = True, sort_cats: bool = False) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Set the appropriate columns of the Achilles data as factors.</p>
<p>If the column is not actually in the data frame, it is just skipped.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Achilles DataFrame.</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>Union[List[str], Tuple[str, &hellip;]]</code>, optional</dt>
<dd>The names of the columns to
make categorical. Defaults to ("hugo_symbol", "depmap_id", "sgrna",
"lineage", "sgrna_target_chr", "p_dna_batch", "screen").</dd>
<dt><strong><code>ordered</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the categorical columns be ordered?
Defaults to True.</dd>
<dt><strong><code>sort_cats</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the categorical columns be sorted?
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The modified DataFrame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_achilles_categorical_columns(
    data: pd.DataFrame,
    cols: Iterable[str] = _default_achilles_categorical_cols,
    ordered: bool = True,
    sort_cats: bool = False,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Set the appropriate columns of the Achilles data as factors.

    If the column is not actually in the data frame, it is just skipped.

    Args:
        data (pd.DataFrame): Achilles DataFrame.
        cols (Union[List[str], Tuple[str, ...]], optional): The names of the columns to
          make categorical. Defaults to (&#34;hugo_symbol&#34;, &#34;depmap_id&#34;, &#34;sgrna&#34;,
          &#34;lineage&#34;, &#34;sgrna_target_chr&#34;, &#34;p_dna_batch&#34;, &#34;screen&#34;).
        ordered (bool, optional): Should the categorical columns be ordered?
          Defaults to True.
        sort_cats (bool, optional): Should the categorical columns be sorted?
          Defaults to False.

    Returns:
        pd.DataFrame: The modified DataFrame.
    &#34;&#34;&#34;
    for col in cols:
        if col in data.columns:
            data = dphelp.make_cat(data, col, ordered=ordered, sort_cats=sort_cats)
    return data</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.sort_achilles_data"><code class="name flex">
<span>def <span class="ident">sort_achilles_data</span></span>(<span>data: pandas.core.frame.DataFrame) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Sort a CRISPR screen data frame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>CRISPR screen data frame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Sorted data frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_achilles_data(data: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Sort a CRISPR screen data frame.

    Args:
        data (pd.DataFrame): CRISPR screen data frame.

    Returns:
        pd.DataFrame: Sorted data frame.
    &#34;&#34;&#34;
    return data.sort_values(
        [&#34;hugo_symbol&#34;, &#34;sgrna&#34;, &#34;lineage&#34;, &#34;depmap_id&#34;]
    ).reset_index(drop=True)</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.subsample_achilles_data"><code class="name flex">
<span>def <span class="ident">subsample_achilles_data</span></span>(<span>df: pandas.core.frame.DataFrame, n_genes: Optional[int] = 100, n_cell_lines: Optional[int] = None) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Subsample an Achilles data set to a number of genes and/or cell lines.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Achilles data.</dd>
<dt><strong><code>n_genes</code></strong> :&ensp;<code>Optional[int]</code>, optional</dt>
<dd>Number of genes to subsample.
Defaults to 100.</dd>
<dt><strong><code>n_cell_lines</code></strong> :&ensp;<code>Optional[int]</code>, optional</dt>
<dd>Number of cell lines to subsample.
Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the number of genes or cell lines is not positive.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The Achilles data set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subsample_achilles_data(
    df: pd.DataFrame, n_genes: Optional[int] = 100, n_cell_lines: Optional[int] = None
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Subsample an Achilles data set to a number of genes and/or cell lines.

    Args:
        df (pd.DataFrame): Achilles data.
        n_genes (Optional[int], optional): Number of genes to subsample.
          Defaults to 100.
        n_cell_lines (Optional[int], optional): Number of cell lines to subsample.
          Defaults to None.

    Raises:
        ValueError: If the number of genes or cell lines is not positive.

    Returns:
        pd.DataFrame: The Achilles data set.
    &#34;&#34;&#34;
    if n_genes is not None and n_genes &lt;= 0:
        raise ValueError(&#34;Number of genes must be positive.&#34;)
    if n_cell_lines is not None and n_cell_lines &lt;= 0:
        raise ValueError(&#34;Number of cell lines must be positive.&#34;)

    genes: np.ndarray = df.hugo_symbol.unique()
    cell_lines: np.ndarray = df.depmap_id.unique()

    if n_genes is not None:
        genes = np.random.choice(genes, n_genes, replace=False)

    if n_cell_lines is not None:
        cell_lines = np.random.choice(cell_lines, n_cell_lines, replace=False)

    sub_df: pd.DataFrame = df.copy()
    sub_df = sub_df[sub_df.hugo_symbol.isin(genes)]
    sub_df = sub_df[sub_df.depmap_id.isin(cell_lines)]
    return sub_df</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.zscale_cna_by_group"><code class="name flex">
<span>def <span class="ident">zscale_cna_by_group</span></span>(<span>df: pandas.core.frame.DataFrame, cn_col: str = 'copy_number', new_col: str = 'copy_number_z', groupby_cols: Union[list[str], tuple[str, ...], NoneType] = ('hugo_symbol',), cn_max: Optional[float] = None) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Z-scale the copy number values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The DataFrame to modify.</dd>
<dt><strong><code>cn_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column with the gene copy number values.
Defaults to "copy_number".</dd>
<dt><strong><code>new_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the column to store the calculated values.
Defaults to "copy_number_z".</dd>
<dt><strong><code>groupby_cols</code></strong> :&ensp;<code>Optional[Union[List[str], Tuple[str, &hellip;]]]</code>, optional</dt>
<dd>A list or
tuple of columns to group the DataFrame by. If None, the rows are not grouped.
Defaults to ("hugo_symbol").</dd>
<dt><strong><code>cn_max</code></strong> :&ensp;<code>Optional[float]</code>, optional</dt>
<dd>The maximum copy number to use.
Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The modified DataFrame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zscale_cna_by_group(
    df: pd.DataFrame,
    cn_col: str = &#34;copy_number&#34;,
    new_col: str = &#34;copy_number_z&#34;,
    groupby_cols: Optional[Union[list[str], tuple[str, ...]]] = (&#34;hugo_symbol&#34;,),
    cn_max: Optional[float] = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Z-scale the copy number values.

    Args:
        df (pd.DataFrame): The DataFrame to modify.
        cn_col (str, optional): Column with the gene copy number values.
          Defaults to &#34;copy_number&#34;.
        new_col (str, optional): The name of the column to store the calculated values.
          Defaults to &#34;copy_number_z&#34;.
        groupby_cols (Optional[Union[List[str], Tuple[str, ...]]], optional): A list or
          tuple of columns to group the DataFrame by. If None, the rows are not grouped.
          Defaults to (&#34;hugo_symbol&#34;).
        cn_max (Optional[float], optional): The maximum copy number to use.
          Defaults to None.

    Returns:
        pd.DataFrame: The modified DataFrame.
    &#34;&#34;&#34;
    if cn_max is not None and cn_max &gt; 0:
        df[new_col] = squish_array(df[cn_col].values, lower=0, upper=cn_max)
    else:
        df[new_col] = df[cn_col]

    def zscore_cna_col(d: pd.DataFrame) -&gt; pd.DataFrame:
        d[new_col] = careful_zscore(d[new_col].values)
        return d

    if groupby_cols is None:
        df = zscore_cna_col(df)
    else:
        df = df.groupby(list(groupby_cols)).apply(zscore_cna_col)

    return df</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.zscale_rna_expression"><code class="name flex">
<span>def <span class="ident">zscale_rna_expression</span></span>(<span>df: pandas.core.frame.DataFrame, rna_col: str = 'rna_expr', new_col: Optional[str] = None, lower_bound: Optional[float] = None, upper_bound: Optional[float] = None) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Z-scale RNA expression data.</p>
<p>If there is not enough variation in the values, dividing by the standard deviation
becomes very unstable. Thus, in this function, if the values are all too similar,
all are set to 0 instead of either <code>NaN</code> or very extreme values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Data frame.</dd>
<dt><strong><code>rna_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column with RNA expr data. Defaults to "rna_expr".</dd>
<dt><strong><code>new_col</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Name of the new column to be generated.
Defaults to <code>f"{rna_col}_z"</code> if None.</dd>
<dt><strong><code>lower_bound</code></strong> :&ensp;<code>Optional[float]</code>, optional</dt>
<dd>Hard lower bound on the scaled values.
Defaults to None.</dd>
<dt><strong><code>upper_bound</code></strong> :&ensp;<code>Optional[float]</code>, optional</dt>
<dd>Hard upper bound on the scaled values.
Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The original data frame with a new column with the z-scaled RNA
expression values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zscale_rna_expression(
    df: pd.DataFrame,
    rna_col: str = &#34;rna_expr&#34;,
    new_col: Optional[str] = None,
    lower_bound: Optional[float] = None,
    upper_bound: Optional[float] = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Z-scale RNA expression data.

    If there is not enough variation in the values, dividing by the standard deviation
    becomes very unstable. Thus, in this function, if the values are all too similar,
    all are set to 0 instead of either `NaN` or very extreme values.

    Args:
        df (pd.DataFrame): Data frame.
        rna_col (str, optional): Column with RNA expr data. Defaults to &#34;rna_expr&#34;.
        new_col (Optional[str], optional): Name of the new column to be generated.
          Defaults to `f&#34;{rna_col}_z&#34;` if None.
        lower_bound (Optional[float], optional): Hard lower bound on the scaled values.
          Defaults to None.
        upper_bound (Optional[float], optional): Hard upper bound on the scaled values.
          Defaults to None.

    Returns:
        pd.DataFrame: The original data frame with a new column with the z-scaled RNA
          expression values.
    &#34;&#34;&#34;
    if new_col is None:
        new_col = rna_col + &#34;_z&#34;

    rna = df[rna_col].values
    rna_z = careful_zscore(rna, atol=0.01, transform=lambda x: np.log10(x + 1))

    if lower_bound is not None and upper_bound is not None:
        rna_z = squish_array(rna_z, lower=lower_bound, upper=upper_bound)

    df[new_col] = rna_z
    return df</code></pre>
</details>
</dd>
<dt id="speclet.data_processing.crispr.zscale_rna_expression_by_gene_lineage"><code class="name flex">
<span>def <span class="ident">zscale_rna_expression_by_gene_lineage</span></span>(<span>df: pandas.core.frame.DataFrame, *args: Union[str, NoneType, float], **kwargs: Union[str, NoneType, float]) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Z-scale RNA expression data grouping by lineage and gene.</p>
<p>All positional and keyword arguments are passed to <code><a title="speclet.data_processing.crispr.zscale_rna_expression" href="#speclet.data_processing.crispr.zscale_rna_expression">zscale_rna_expression()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The Achilles data frame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The original data frame with a new column with the z-scaled RNA
expression values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zscale_rna_expression_by_gene_lineage(
    df: pd.DataFrame,
    *args: ArgToZscaleByExpression,
    **kwargs: ArgToZscaleByExpression,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Z-scale RNA expression data grouping by lineage and gene.

    All positional and keyword arguments are passed to `zscale_rna_expression()`.

    Args:
        df (pd.DataFrame): The Achilles data frame.

    Returns:
        pd.DataFrame: The original data frame with a new column with the z-scaled RNA
          expression values.
    &#34;&#34;&#34;
    return df.groupby([&#34;lineage&#34;, &#34;hugo_symbol&#34;]).apply(
        zscale_rna_expression, *args, **kwargs
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="speclet.data_processing.crispr.CommonIndices"><code class="flex name class">
<span>class <span class="ident">CommonIndices</span></span>
<span>(</span><span>*, sgrna_idx: numpy.ndarray, n_sgrnas: int = 0, sgrna_to_gene_map: pandas.core.frame.DataFrame, sgrna_to_gene_idx: numpy.ndarray, gene_idx: numpy.ndarray, n_genes: int = 0, cellline_idx: numpy.ndarray, n_celllines: int = 0, lineage_idx: numpy.ndarray, n_lineages: int = 0, cellline_to_lineage_map: pandas.core.frame.DataFrame, cellline_to_lineage_idx: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Object to hold common indices used for modeling Achilles data.</p>
<p>Object to hold common indices used for modeling Achilles data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommonIndices(BaseModel):
    &#34;&#34;&#34;Object to hold common indices used for modeling Achilles data.&#34;&#34;&#34;

    sgrna_idx: np.ndarray
    n_sgrnas: int = 0
    sgrna_to_gene_map: pd.DataFrame
    sgrna_to_gene_idx: np.ndarray
    gene_idx: np.ndarray
    n_genes: int = 0
    cellline_idx: np.ndarray
    n_celllines: int = 0
    lineage_idx: np.ndarray
    n_lineages: int = 0
    cellline_to_lineage_map: pd.DataFrame
    cellline_to_lineage_idx: np.ndarray

    def __init__(self, **data: Union[int, np.ndarray, pd.DataFrame]):
        &#34;&#34;&#34;Object to hold common indices used for modeling Achilles data.&#34;&#34;&#34;
        super().__init__(**data)
        self.n_sgrnas = dphelp.nunique(self.sgrna_idx)
        self.n_genes = dphelp.nunique(self.gene_idx)
        self.n_celllines = dphelp.nunique(self.cellline_idx)
        self.n_lineages = dphelp.nunique(self.lineage_idx)

    class Config:
        &#34;&#34;&#34;Configuration for pydantic validation.&#34;&#34;&#34;

        arbitrary_types_allowed = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="speclet.data_processing.crispr.CommonIndices.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"><p>Configuration for pydantic validation.</p></div>
</dd>
</dl>
</dd>
<dt id="speclet.data_processing.crispr.DataBatchIndices"><code class="flex name class">
<span>class <span class="ident">DataBatchIndices</span></span>
<span>(</span><span>*, batch_idx: numpy.ndarray, n_batches: int = 0, screen_idx: numpy.ndarray, n_screens: int = 0, batch_to_screen_map: pandas.core.frame.DataFrame, batch_to_screen_idx: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Object to hold indices relating to data screens and batches.</p>
<p>Object to hold indices relating to data screens and batches.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataBatchIndices(BaseModel):
    &#34;&#34;&#34;Object to hold indices relating to data screens and batches.&#34;&#34;&#34;

    batch_idx: np.ndarray
    n_batches: int = 0
    screen_idx: np.ndarray
    n_screens: int = 0
    batch_to_screen_map: pd.DataFrame
    batch_to_screen_idx: np.ndarray

    def __init__(self, **data: Union[int, np.ndarray, pd.DataFrame]):
        &#34;&#34;&#34;Object to hold indices relating to data screens and batches.&#34;&#34;&#34;
        super().__init__(**data)
        self.n_batches = dphelp.nunique(self.batch_idx)
        self.n_screens = dphelp.nunique(self.screen_idx)

    class Config:
        &#34;&#34;&#34;Configuration for pydantic validation.&#34;&#34;&#34;

        arbitrary_types_allowed = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="speclet.data_processing.crispr.DataBatchIndices.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"><p>Configuration for pydantic validation.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="speclet.data_processing" href="index.html">speclet.data_processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="speclet.data_processing.crispr.add_useful_read_count_columns" href="#speclet.data_processing.crispr.add_useful_read_count_columns">add_useful_read_count_columns</a></code></li>
<li><code><a title="speclet.data_processing.crispr.append_total_read_counts" href="#speclet.data_processing.crispr.append_total_read_counts">append_total_read_counts</a></code></li>
<li><code><a title="speclet.data_processing.crispr.common_indices" href="#speclet.data_processing.crispr.common_indices">common_indices</a></code></li>
<li><code><a title="speclet.data_processing.crispr.data_batch_indices" href="#speclet.data_processing.crispr.data_batch_indices">data_batch_indices</a></code></li>
<li><code><a title="speclet.data_processing.crispr.drop_missing_copynumber" href="#speclet.data_processing.crispr.drop_missing_copynumber">drop_missing_copynumber</a></code></li>
<li><code><a title="speclet.data_processing.crispr.drop_sgrnas_that_map_to_multiple_genes" href="#speclet.data_processing.crispr.drop_sgrnas_that_map_to_multiple_genes">drop_sgrnas_that_map_to_multiple_genes</a></code></li>
<li><code><a title="speclet.data_processing.crispr.filter_for_broad_source_only" href="#speclet.data_processing.crispr.filter_for_broad_source_only">filter_for_broad_source_only</a></code></li>
<li><code><a title="speclet.data_processing.crispr.make_cell_line_to_lineage_mapping_df" href="#speclet.data_processing.crispr.make_cell_line_to_lineage_mapping_df">make_cell_line_to_lineage_mapping_df</a></code></li>
<li><code><a title="speclet.data_processing.crispr.make_kras_mutation_index_with_other" href="#speclet.data_processing.crispr.make_kras_mutation_index_with_other">make_kras_mutation_index_with_other</a></code></li>
<li><code><a title="speclet.data_processing.crispr.make_mapping_df" href="#speclet.data_processing.crispr.make_mapping_df">make_mapping_df</a></code></li>
<li><code><a title="speclet.data_processing.crispr.make_sgrna_to_gene_mapping_df" href="#speclet.data_processing.crispr.make_sgrna_to_gene_mapping_df">make_sgrna_to_gene_mapping_df</a></code></li>
<li><code><a title="speclet.data_processing.crispr.read_achilles_data" href="#speclet.data_processing.crispr.read_achilles_data">read_achilles_data</a></code></li>
<li><code><a title="speclet.data_processing.crispr.set_achilles_categorical_columns" href="#speclet.data_processing.crispr.set_achilles_categorical_columns">set_achilles_categorical_columns</a></code></li>
<li><code><a title="speclet.data_processing.crispr.sort_achilles_data" href="#speclet.data_processing.crispr.sort_achilles_data">sort_achilles_data</a></code></li>
<li><code><a title="speclet.data_processing.crispr.subsample_achilles_data" href="#speclet.data_processing.crispr.subsample_achilles_data">subsample_achilles_data</a></code></li>
<li><code><a title="speclet.data_processing.crispr.zscale_cna_by_group" href="#speclet.data_processing.crispr.zscale_cna_by_group">zscale_cna_by_group</a></code></li>
<li><code><a title="speclet.data_processing.crispr.zscale_rna_expression" href="#speclet.data_processing.crispr.zscale_rna_expression">zscale_rna_expression</a></code></li>
<li><code><a title="speclet.data_processing.crispr.zscale_rna_expression_by_gene_lineage" href="#speclet.data_processing.crispr.zscale_rna_expression_by_gene_lineage">zscale_rna_expression_by_gene_lineage</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="speclet.data_processing.crispr.CommonIndices" href="#speclet.data_processing.crispr.CommonIndices">CommonIndices</a></code></h4>
<ul class="">
<li><code><a title="speclet.data_processing.crispr.CommonIndices.Config" href="#speclet.data_processing.crispr.CommonIndices.Config">Config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="speclet.data_processing.crispr.DataBatchIndices" href="#speclet.data_processing.crispr.DataBatchIndices">DataBatchIndices</a></code></h4>
<ul class="">
<li><code><a title="speclet.data_processing.crispr.DataBatchIndices.Config" href="#speclet.data_processing.crispr.DataBatchIndices.Config">Config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>